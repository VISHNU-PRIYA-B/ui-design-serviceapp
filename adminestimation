// @ts-nocheck
import React, { useEffect, useState, useContext, useLayoutEffect } from "react";
import {View,Text,StyleSheet,TouchableOpacity,Alert,ActivityIndicator,Linking,ScrollView,} from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import { graphqlRequest, setAuthToken, BACKEND_BASE_URL } from "../services/api";
import { UserContext } from "../components/ui/UserContext";
import { useLogout } from "../hooks/Logout";
import { useNavigation } from "@react-navigation/native";
import AsyncStorage from "@react-native-async-storage/async-storage";

/* COLORS */
const COLORS = {
  gradientStart: "#8B7FE8",
  gradientEnd: "#A89DEF",
  white: "#FFFFFF",
  primary: "#7B6EF6",
  textDark: "#1E1E1E",
  textMuted: "#8A8A8A",
  cardBg: "#FFFFFF",
  cardBorder: "#ECECF3",
  sectionBg: "#F7F8FC",
  success: "#27AE60",
  danger: "#E74C3C",
  link: "#3498DB",

  pending: "#FFF3CD",
  pendingText: "#856404",
  started: "#DFF5E1",
  startedText: "#155724",
  repairing: "#CCE4FF",
  repairingText: "#004085",
  testing: "#CFF4FC",
  testingText: "#0C5460",
  ready: "#E5D9F2",
  readyText: "#6B4B9E",
  rejected: "#F8D7DA",
  rejectedText: "#721C24",
};



export default function ApproveEstimation() {
  const { token: contextToken } = useContext(UserContext);
  const [estimations, setEstimations] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);

  const logout = useLogout();
  const navigation = useNavigation();
  useLayoutEffect(() => {
  navigation.setOptions({
    title: "Estimations",
    headerStyle: { backgroundColor: "#a88ce9" },
    headerTintColor: "#fff",
  });
}, []);


  useLayoutEffect(() => {
    navigation.setOptions({
      headerRight: () => (
        <TouchableOpacity onPress={logout} style={{ marginRight: 15 }}>
          <Text style={{ color: "#E74C3C", fontWeight: "bold" }}>Logout</Text>
        </TouchableOpacity>
      ),
    });
  }, []);

  /* FETCH */
  const fetchMyEstimations = async () => {
    const token = contextToken || (await AsyncStorage.getItem("token"));
    if (!token) return;

    setAuthToken(token);
    setLoading(true);

    const query = `
      query {
        myEstimations {
          id
          total
          invoice {
            invoiceNumber
            pdfUrl
          }
          repairRequest {
            requestId
            itemName
            problemDescription
            createdAt
            status
          }
          items {
            id
            description
            quantity
            unitPrice
            amount
          }
        }
      }
    `;

    try {
      const res = await graphqlRequest(query);
      setEstimations(res?.myEstimations || []);
    } catch {
      Alert.alert("Error", "Failed to fetch estimations");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMyEstimations();
  }, []);

  /*MERGE SAME REQUEST ID */
  const mergedEstimations = Object.values(
    estimations.reduce((acc: any, item: any) => {
      const key = item.repairRequest.requestId;

      if (!acc[key]) {
        acc[key] = {
          ...item,
          items: [...(item.items || [])],
        };
      } else {
        acc[key].items = [...acc[key].items, ...(item.items || [])];
      }

      return acc;
    }, {})
  );

  /* SORT */
  const sortedEstimations = [...mergedEstimations].sort(
    (a, b) =>
      new Date(b.repairRequest.createdAt).getTime() -
      new Date(a.repairRequest.createdAt).getTime()
  );

  /* GROUP BY DATE */
  const groupedData = sortedEstimations.reduce((acc: any, item: any) => {
    const dateKey = new Date(item.repairRequest.createdAt).toLocaleDateString(
      "en-IN",
      {
        day: "2-digit",
        month: "short",
        year: "numeric",
      }
    );

    if (!acc[dateKey]) acc[dateKey] = [];
    acc[dateKey].push(item);
    return acc;
  }, {});

  const getStatusColors = (status: string) => {
    switch (status) {
      case "PENDING":
        return { bg: COLORS.pending, text: COLORS.pendingText };
      case "READY_TO_DELIVER":
        return { bg: COLORS.ready, text: COLORS.readyText };
      case "REJECTED":
        return { bg: COLORS.rejected, text: COLORS.rejectedText };
      default:
        return { bg: "#EEE", text: "#333" };
    }
  };

  const formatStatus = (status: string) => status.replaceAll("_", " ");

  if (loading) {
    return (
      <LinearGradient colors={[COLORS.gradientStart, COLORS.gradientEnd]} style={styles.center}>
        <ActivityIndicator size="large" color="#fff" />
      </LinearGradient>
    );
  }

  return (
    <LinearGradient colors={[COLORS.gradientStart, COLORS.gradientEnd]} style={styles.container}>
      <ScrollView contentContainerStyle={styles.contentContainer}>

        {Object.keys(groupedData).map((date) => (
          <View key={date}>

            <Text style={styles.dateHeader}>{date}</Text>

            {groupedData[date].map((item) => {
              const total = item.items.reduce(
                (s: number, i: any) => s + Number(i.amount),
                0
              );

              const statusColors = getStatusColors(item.repairRequest.status);

              return (
                <View key={item.repairRequest.requestId} style={styles.card}>

                  <View style={styles.cardHeader}>
                    <Text style={styles.itemName}>{item.repairRequest.itemName}</Text>
                    <View style={[styles.statusBadge, { backgroundColor: statusColors.bg }]}>
                      <Text style={[styles.statusText, { color: statusColors.text }]}>
                        {formatStatus(item.repairRequest.status)}
                      </Text>
                    </View>
                  </View>

                  <Text style={styles.problemText}>
                    {item.repairRequest.problemDescription}
                  </Text>

                  {item.items.map((i: any) => (
                    <View key={i.id} style={styles.itemRow}>
                      <Text>{i.description}</Text>
                      <Text>â‚¹{i.amount}</Text>
                    </View>
                  ))}

                  <View style={styles.totalRow}>
                    <Text>Total</Text>
                    <Text>â‚¹{total}</Text>
                  </View>

                  {item.invoice?.pdfUrl && (
                    <TouchableOpacity
                      onPress={() => {
                        const url = item.invoice.pdfUrl.startsWith("http")
                          ? item.invoice.pdfUrl
                          : `${BACKEND_BASE_URL}${item.invoice.pdfUrl}`;
                        Linking.openURL(url);
                      }}
                    >
                      <Text style={styles.invoice}>ðŸ“„ View Invoice</Text>
                    </TouchableOpacity>
                  )}

                </View>
              );
            })}
          </View>
        ))}

      </ScrollView>
    </LinearGradient>
  );
}

/* STYLES */
const styles = StyleSheet.create({
  container: { flex: 1 },
  contentContainer: { padding: 16 },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },
  card: {
    backgroundColor: "#fff",
    borderRadius: 20,
    padding: 16,
    marginBottom: 16,
  },
  cardHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
  },
  itemName: { fontSize: 18, fontWeight: "700" },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
  },
  statusText: { fontSize: 11, fontWeight: "700" },
  problemText: { marginVertical: 8 },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginVertical: 4,
  },
  totalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 10,
    fontWeight: "700",
  },
  invoice: {
    textAlign: "center",
    marginTop: 10,
    color: COLORS.link,
    fontWeight: "600",
  },
  dateHeader: {
    color: "#fff",
    fontWeight: "700",
    marginBottom: 10,
  },
});
