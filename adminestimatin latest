// @ts-nocheck
import React, {useEffect,useState,useContext,useLayoutEffect,} from "react";
import {View,Text,StyleSheet,TouchableOpacity,Alert,ActivityIndicator,Linking,ScrollView,TextInput,} from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import {graphqlRequest,setAuthToken,BACKEND_BASE_URL,} from "../services/api";
import { UserContext } from "../components/ui/UserContext";
import { useNavigation } from "@react-navigation/native";
import AsyncStorage from "@react-native-async-storage/async-storage";

/* COLORS */
const COLORS = {
  gradientStart: "#8B7FE8",
  gradientEnd: "#A89DEF",
  link: "#3498DB",
  pending: "#FFF3CD",
  pendingText: "#856404",
  ready: "#E5D9F2",
  readyText: "#6B4B9E",
  rejected: "#F8D7DA",
  rejectedText: "#721C24",
  accepted: "#b5d9b0",
  acceptedText: "#4dd33c",
  started: "#b8eee7",
  startedText: "#179e8c",
  repairing: "#f3e6ce",
  repairingText: "#e88419",
  testing: "#f1e2f4",
  testingText: "#c96dd9",
};

export default function ApproveEstimation() {
  const { token: contextToken } = useContext(UserContext);
  const navigation = useNavigation();

  const [estimations, setEstimations] = useState([]);
  const [loading, setLoading] = useState(false);
  const [search, setSearch] = useState("");
  const [showSearch, setShowSearch] = useState(false);

  /* HEADER */
  useLayoutEffect(() => {
    navigation.setOptions({
      title: "Estimations",
      headerStyle: { backgroundColor: "#a88ce9" },
      headerTintColor: "#fff",
      headerRight: () => (
        <TouchableOpacity
          onPress={() => setShowSearch((p) => !p)}
          style={{ marginRight: 16 }}
        >
          <Text style={{ fontSize: 22, color: "#fff" }}>â˜°</Text>
        </TouchableOpacity>
      ),
    });
  }, [navigation]);

  /* FETCH */
  const fetchMyEstimations = async () => {
    const token = contextToken || (await AsyncStorage.getItem("token"));
    if (!token) return;

    setAuthToken(token);
    setLoading(true);

    const query = `
      query {
        myEstimations {
          id
          status
          createdAt
          repairRequest {
            requestId
            customerName
            itemName
            problemDescription
            createdAt
            invoice {
              pdfUrl
            }
          }
          items {
            id
            description
            amount
          }
        }
      }
    `;

    try {
      const res = await graphqlRequest(query);
      setEstimations(res?.myEstimations || []);
    } catch {
      Alert.alert("Error", "Failed to fetch estimations");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMyEstimations();
  }, []);

  /* SEARCH */
  const filteredEstimations = estimations.filter((item) => {
    if (!search) return true;
    const text = search.toLowerCase();

      // ðŸ”¹ Convert date to searchable strings
  const date = new Date(item.createdAt);

  const monthName = date.toLocaleString("en-US", { month: "long" }).toLowerCase(); // february
  const monthShort = date.toLocaleString("en-US", { month: "short" }).toLowerCase(); // feb
  const year = date.getFullYear().toString(); // 2026
  

    return (
      item.repairRequest.customerName.toLowerCase().includes(text) ||
      item.repairRequest.itemName.toLowerCase().includes(text) ||
      item.repairRequest.problemDescription.toLowerCase().includes(text) ||
      item.repairRequest.requestId.toLowerCase().includes(text) ||

      monthName.includes(text) ||
      monthShort.includes(text) ||
      year.includes(text) 
    );
  });

  /* GROUP BY REQUEST */
  const groupedByRequest = Object.values(
    filteredEstimations.reduce((acc, est) => {
      const key = est.repairRequest.requestId;
      const estDate = new Date(est.createdAt);

      if (!acc[key]) {
        acc[key] = {
          repairRequest: est.repairRequest,
          status: est.status,
          latestDate: estDate,
          items: [...est.items],
        };
      } else {
        acc[key].items.push(...est.items);
        if (estDate > acc[key].latestDate) {
          acc[key].status = est.status;
          acc[key].latestDate = estDate;
        }
      }
      return acc;
    }, {})
  );

  /* GROUP BY DATE */
 const groupedData = Object.values(
  groupedByRequest.reduce((acc, item) => {
    const dateObj = new Date(item.repairRequest.createdAt);

    const dateKey = dateObj.toLocaleDateString("en-IN", {
      day: "2-digit",
      month: "short",
      year: "numeric",
    });

    if (!acc[dateKey]) {
      acc[dateKey] = {
        date: dateKey,
        items: [],
      };
    }

    acc[dateKey].items.push(item);
    return acc;
  }, {})
).sort(
  (a, b) =>
    new Date(b.items[0].repairRequest.createdAt) -
    new Date(a.items[0].repairRequest.createdAt)
);
  const getStatusColors = (status) => {
    switch (status) {
      case "READY_TO_DELIVER":
        return { bg: COLORS.ready, text: COLORS.readyText };
      case "REJECTED":
        return { bg: COLORS.rejected, text: COLORS.rejectedText };
      case "ACCEPTED":
        return { bg: COLORS.accepted, text: COLORS.acceptedText };
      case "STARTED":
        return { bg: COLORS.started, text: COLORS.startedText };
      case "REPAIRING":
        return { bg: COLORS.repairing, text: COLORS.repairingText };
      case "TESTING":
        return { bg: COLORS.testing, text: COLORS.testingText };
      default:
        return { bg: COLORS.pending, text: COLORS.pendingText };
    }
  };

  if (loading) {
    return (
      <LinearGradient
        colors={[COLORS.gradientStart, COLORS.gradientEnd]}
        style={styles.center}
      >
        <ActivityIndicator size="large" color="#fff" />
      </LinearGradient>
    );
  }

  return (
    <LinearGradient
      colors={[COLORS.gradientStart, COLORS.gradientEnd]}
      style={styles.container}
    >
              {showSearch && (
          <View style={styles.searchBox}>
            <TextInput
              placeholder="Search..."
              value={search}
              onChangeText={setSearch}
              style={styles.searchInput}
            />
          </View>
        )}
      
 
      <ScrollView  contentContainerStyle={[styles.contentContainer,{ paddingTop: showSearch ? 20 : 13 }, ]}>


        {groupedData.map((group) => (
          <View key={group.date}>
            <Text style={styles.dateHeader}>{group.date}</Text>

            {group.items.map((item) => {
              const total = item.items.reduce(
                (s, i) => s + Number(i.amount),
                0
              );
              const statusColors = getStatusColors(item.status);

              return (
                <View
                  key={item.repairRequest.requestId}
                  style={styles.card}
                >
                  <View style={styles.cardHeader}>
                    <Text style={{ flexShrink: 1 }}>
                      Name: {item.repairRequest.customerName}
                    </Text>
                    <View
                      style={[
                        styles.statusBadge,
                        { backgroundColor: statusColors.bg },
                      ]}
                    >
                      <Text
                        style={{
                          color: statusColors.text,
                          fontSize: 12,
                          fontWeight: "600",
                        }}
                      >
                        {item.status.replaceAll("_", " ")}
                      </Text>
                    </View>
                  </View>

                  <Text>Item: {item.repairRequest.itemName}</Text>
                  <Text>
                    Problem: {item.repairRequest.problemDescription}
                  </Text>

                  {item.items.map((i) => (
                    <View key={i.id} style={styles.itemRow}>
                      <Text style={{ flex: 1 }}>â€¢ {i.description}</Text>
                      <Text>â‚¹{i.amount}</Text>
                    </View>
                  ))}

                  <View style={styles.totalRow}>
                    <Text style={{ fontWeight: "700" }}>Total</Text>
                    <Text style={{ fontWeight: "700" }}>â‚¹{total}</Text>
                  </View>

                  {item.status === "READY_TO_DELIVER" &&
                    item.repairRequest.invoice?.pdfUrl && (
                      <TouchableOpacity
                        onPress={() => {
                          const url =
                            item.repairRequest.invoice.pdfUrl.startsWith(
                              "http"
                            )
                              ? item.repairRequest.invoice.pdfUrl
                              : `${BACKEND_BASE_URL}${item.repairRequest.invoice.pdfUrl}`;
                          Linking.openURL(url);
                        }}
                      >
                        <Text style={styles.invoice}>
                          ðŸ“„ View Invoice
                        </Text>
                      </TouchableOpacity>
                    )}
                </View>
              );
            })}
          </View>
        ))}
      </ScrollView>
    </LinearGradient>
  );
}

/* STYLES */
const styles = StyleSheet.create({
  container: { flex: 1 },
  contentContainer: { padding: 16 },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },



searchBox: {
  backgroundColor: "#fff",
  borderRadius: 14,
  padding: 12,
  elevation: 4,
},

  searchInput: { fontSize: 16 },
  card: {
    backgroundColor: "#fff",
    borderRadius: 20,
    padding: 16,
    marginBottom: 20,
  },
  cardHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 6,
  },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
  },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginVertical: 4,
  },
  totalRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginTop: 12,
    paddingTop: 10,
    borderTopWidth: 1,
  },
  invoice: {
    textAlign: "center",
    marginTop: 10,
    color: COLORS.link,
    fontWeight: "600",
  },
  dateHeader: {
    color: "#fff",
    fontWeight: "700",
    marginBottom: 8,
  },
});
