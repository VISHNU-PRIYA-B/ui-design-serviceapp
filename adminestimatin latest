// @ts-nocheck
import React, {useEffect,useState,useContext,useLayoutEffect,useCallback,} from "react";
import {View,Text,StyleSheet,TouchableOpacity,Alert,ActivityIndicator,Linking,ScrollView,TextInput,} from "react-native";
import { LinearGradient } from "expo-linear-gradient";
import {graphqlRequest,setAuthToken,BACKEND_BASE_URL,} from "../services/api";
import { UserContext } from "../components/ui/UserContext";
import { useFocusEffect, useNavigation } from "@react-navigation/native";
import AsyncStorage from "@react-native-async-storage/async-storage";

/* COLORS */
const COLORS = {
  gradientStart: "#8B7FE8",
  gradientEnd: "#A89DEF",
  link: "#3498DB",
  pending: "#FFF3CD",
  pendingText: "#856404",
  ready: "#E5D9F2",
  readyText: "#6B4B9E",
  rejected: "#F8D7DA",
  rejectedText: "#721C24",

  accepted:"#b5d9b0",
  acceptedText:"#4dd33c",
  started:"#b8eee7",
  startedText:"#179e8c",
  repairing:"#f3e6ce",
  repairingText:"#e88419",
  testing:"#f1e2f4",
  testingText:"#c96dd9"
};

export default function ApproveEstimation() {
  const { token: contextToken } = useContext(UserContext);
  const navigation = useNavigation();
  const [estimations, setEstimations] = useState([]);
  const [loading, setLoading] = useState(false);
  const [search, setSearch] = useState("");
  const [showSearch, setShowSearch] = useState(false);
  // const [menuVisible, setMenuVisible] = useState(false);

  /* HEADER */
  useLayoutEffect(() => {
    navigation.setOptions({
      title: "Estimations",
      headerStyle: { backgroundColor: "#a88ce9" },
      headerTintColor: "#fff",
      headerRight: () => (
        <TouchableOpacity
          onPress={() => setShowSearch(prev => !prev)}
          style={{ marginRight: 16 }}
        >
          <Text style={{ fontSize: 22, color: "#fff" }}>â˜°</Text>
        </TouchableOpacity>
      ),
    });
  }, [navigation]);

  // useFocusEffect(
  //   useCallback(() => {
  //     return () => setMenuVisible(false);
  //   }, [])
  // );

  /* FETCH */
  const fetchMyEstimations = async () => {
    const token = contextToken || (await AsyncStorage.getItem("token"));
    if (!token) return;

    setAuthToken(token);
    setLoading(true);

    // const query = `
    //   query {
    //     myEstimations {
    //       id
    //       status
    //       invoice { pdfUrl }
    //       repairRequest {
    //         requestId
    //         customerName
    //         itemName
    //         problemDescription
    //         createdAt
    //       }
    //       items {
    //         id
    //         description
    //         amount
    //       }
    //     }
    //   }
    // `;
    const query = `
    query {
      myEstimations {
        id
        status
        createdAt
        repairRequest {
          requestId
          customerName
          itemName
          problemDescription
          createdAt
          invoice {
            pdfUrl
          }
        }
        items {
          id
          description
          amount
        }
      }
    }
  `;

    try {
      const res = await graphqlRequest(query);
      setEstimations(res?.myEstimations || []);
    } catch {
      Alert.alert("Error", "Failed to fetch estimations");
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchMyEstimations();
  }, []);

  /* SEARCH FILTER */
  const filteredEstimations = estimations.filter(item => {
    if (!search) return true;
    const text = search.toLowerCase();
    return (
      item.repairRequest.customerName.toLowerCase().includes(text) ||
      item.repairRequest.itemName.toLowerCase().includes(text) ||
      item.repairRequest.problemDescription.toLowerCase().includes(text) ||
      item.repairRequest.requestId.toLowerCase().includes(text)
    );
  });
  console.log("RAW ESTIMATIONS:", estimations);

  /* GROUP BY REPAIR REQUEST ( KEY FIX) */
  const groupedByRequest = Object.values(
    filteredEstimations.reduce((acc, est) => {
      const key = est.repairRequest.requestId;
      const estDate = new Date(est.createdAt);
      console.log(est.status, est.createdAt);

      if (!acc[key]) {
        acc[key] = {
          repairRequest: est.repairRequest,
          status: est.status,
          latestDate:estDate,
          items: [...est.items],
        };
      } else {
        acc[key].items.push(...est.items);

        // if(est.invoice && !acc[key].invoice){
        //   acc[key].invoice=est.invoice;
        // }

        // Prefer READY_TO_DELIVER
        if (estDate>acc[key].latestDate) {
          acc[key].status = est.status;
          acc[key].latestDate=estDate;
          
        }
      }
      return acc;
    }, {})
  );

  /* SORT */
  const sortedData = groupedByRequest.sort(
    (a, b) =>
      new Date(b.repairRequest.createdAt) -
      new Date(a.repairRequest.createdAt)
  );

  const getStatusColors = status => {
    switch (status) {
      case "READY_TO_DELIVER":
        return { bg: COLORS.ready, text: COLORS.readyText };
      case "REJECTED":
        return { bg: COLORS.rejected, text: COLORS.rejectedText };
      case "ACCEPTED":
        return { bg: COLORS.accepted, text: COLORS.acceptedText };
      case "STARTED":
        return { bg: COLORS.started, text: COLORS.startedText };
      case "REPAIRING":
        return { bg: COLORS.repairing, text: COLORS.repairingText };
      case "TESTING":
        return { bg: COLORS.testing, text: COLORS.testingText };

      default:
        return { bg: COLORS.pending, text: COLORS.pendingText };
    }
  };

  if (loading) {
    return (
      <LinearGradient
        colors={[COLORS.gradientStart, COLORS.gradientEnd]}
        style={styles.center}
      >
        <ActivityIndicator size="large" color="#fff" />
      </LinearGradient>
    );
  }

  return (
    <LinearGradient
      colors={[COLORS.gradientStart, COLORS.gradientEnd]}
      style={styles.container}
    >
      <ScrollView contentContainerStyle={styles.contentContainer}>
        {showSearch && (
          <View style={styles.searchBox}>
            <TextInput
              placeholder="Search..."
              value={search}
              onChangeText={setSearch}
              style={styles.searchInput}
            />
          </View>
        )}

        {sortedData.map(item => {
            console.log(
              "REQ:",
              item.repairRequest.requestId,
              "STATUS:",
              item.status,
              "INVOICE:", item.repairRequest.invoice
            );
          const total = item.items.reduce(
            (sum, i) => sum + Number(i.amount),
            0
          );
          const statusColors = getStatusColors(item.status);

          return (
            <View key={item.repairRequest.requestId}>
              <Text style={styles.dateHeader}>
                {new Date(item.repairRequest.createdAt).toLocaleDateString(
                  "en-IN",
                  { day: "2-digit", month: "short", year: "numeric" }
                )}
              </Text>

              <View style={styles.card}>
                <View style={styles.cardHeader}>
                  <Text style={{ flexShrink: 1, paddingRight: 8 }}>Name: {item.repairRequest.customerName}</Text>
                  <View
                    style={[
                      styles.statusBadge,
                      { backgroundColor: statusColors.bg },
                    ]}
                  >
                    <Text style={{     color: statusColors.text,fontWeight: "600",fontSize: 12, }}   numberOfLines={1}ellipsizeMode="tail">
                      {item.status.replaceAll("_", " ")}
                    </Text>
                  </View>
                </View>

                <Text>Item: {item.repairRequest.itemName}</Text>
                <Text>Problem: {item.repairRequest.problemDescription}</Text>

                {item.items.map(i => (
                  <View key={i.id} style={styles.itemRow}>
                    <Text style={{ flex: 1, flexShrink: 1 }}>â€¢ {i.description}</Text>
                    <Text style={{ marginLeft: 8 }}>â‚¹{i.amount}</Text>
                  </View>
                ))}

                <View style={styles.totalRow}>
                  <Text style={{ fontWeight: "700", fontSize: 15 }}>Total</Text>
                  <Text  style={{ fontWeight: "700", fontSize: 15 }}>â‚¹{total}</Text>
                </View>

                {/* {item.status === "READY_TO_DELIVER" &&
                  item.invoice?.pdfUrl && (
                    <TouchableOpacity
                      onPress={() => {
                        const url = item.invoice.pdfUrl.startsWith("http")
                          ? item.invoice.pdfUrl
                          : `${BACKEND_BASE_URL}${item.invoice.pdfUrl}`;
                        Linking.openURL(url);
                      }}
                    >
                      <Text style={styles.invoice}>ðŸ“„ View Invoice</Text>
                    </TouchableOpacity>
                  )} */}
                  {/* {item.status === "READY_TO_DELIVER" &&
                    item.invoice &&
                    item.invoice.pdfUrl && (
                      <TouchableOpacity
                        onPress={() => {
                          const url = item.invoice.pdfUrl.startsWith("http")
                            ? item.invoice.pdfUrl
                            : `${BACKEND_BASE_URL}${item.invoice.pdfUrl}`;
                          Linking.openURL(url);
                        }}
                      >
                        <Text style={styles.invoice}>ðŸ“„ View Invoice</Text>
                      </TouchableOpacity>
                  )} */}
                  {item.status === "READY_TO_DELIVER" &&
                    item.repairRequest.invoice &&
                    item.repairRequest.invoice.pdfUrl && (
                      <TouchableOpacity
                        onPress={() => {
                          const url =
                            item.repairRequest.invoice.pdfUrl.startsWith("http")
                              ? item.repairRequest.invoice.pdfUrl
                              : `${BACKEND_BASE_URL}${item.repairRequest.invoice.pdfUrl}`;
                          Linking.openURL(url);
                        }}
                      >
                        <Text style={styles.invoice}>ðŸ“„ View Invoice</Text>
                      </TouchableOpacity>
                    )}
                                  </View>
                                </View>
                              );
                            })}
                          </ScrollView>
                        </LinearGradient>
                      );
                    }

/* STYLES */
const styles = StyleSheet.create({
  container: { flex: 1 },
  contentContainer: { padding: 16 },
  center: { flex: 1, justifyContent: "center", alignItems: "center" },

  searchBox: {
    backgroundColor: "#fff",
    borderRadius: 14,
    padding: 12,
    marginBottom: 16,
  },
  searchInput: { fontSize: 16 },

  card: {
    backgroundColor: "#fff",
    borderRadius: 20,
    padding: 16,
    marginBottom: 20,
  },
  cardHeader: {
    flexDirection: "row",
    justifyContent: "space-between",

    alignItems:"center",
    marginBottom:6,
  },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 4,
    borderRadius: 20,
    alignSelf: "flex-start",  
    
  },
  itemRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginVertical: 4,
  },
  totalRow: {
  flexDirection: "row",
  justifyContent: "space-between",
  alignItems: "center",
  marginTop: 12,
  paddingTop: 10,
  borderTopWidth: 1,

  },
  invoice: {
    textAlign: "center",
    marginTop: 10,
    color: COLORS.link,
    fontWeight: "600",
  },
  dateHeader: {
    color: "#fff",
    fontWeight: "700",
    marginBottom: 8,
  },
});

